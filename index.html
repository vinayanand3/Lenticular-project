<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Holographic Lenticular</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Helvetica, Arial, sans-serif; }
        canvas { display: block; }
        
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.85);
            z-index: 10;
            color: white;
            text-align: center;
        }
        #start-btn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 1rem;
            background: #fff;
            color: #000;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
            transition: transform 0.2s;
        }
        #start-btn:active { transform: scale(0.95); }
        p { color: #aaa; margin-top: 10px; font-size: 0.9rem; }
    </style>
</head>
<body>

<div id="overlay">
    <h2>Lenticular Effect</h2>
    <p>Tilt device to view transition</p>
    <button id="start-btn">Enter Experience</button>
</div>

<!-- Import Three.js -->
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';

    // 1. CONFIGURATION
    // Use high-contrast images for best holographic effect
    const IMG_1 = 'https://picsum.photos/id/237/1024/1024'; // Dog
    const IMG_2 = 'https://picsum.photos/id/238/1024/1024'; // City
    
    // How many vertical "lenses" across the screen?
    // Higher = smoother, Lower = more retro/plastic feel
    const LENS_COUNT = 80.0; 

    // 2. SCENE SETUP
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 1.2; // Zoomed in slightly to fill screen

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // 3. TEXTURE LOADING
    const loader = new THREE.TextureLoader();
    const loadTex = (url) => {
        const tex = loader.load(url);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.wrapS = THREE.ClampToEdgeWrapping;
        tex.wrapT = THREE.ClampToEdgeWrapping;
        return tex;
    };

    const texture1 = loadTex(IMG_1);
    const texture2 = loadTex(IMG_2);

    // 4. HOLOGRAPHIC SHADER
    const material = new THREE.ShaderMaterial({
        uniforms: {
            uTex1: { value: texture1 },
            uTex2: { value: texture2 },
            uIncline: { value: 0.5 },
            uCount: { value: LENS_COUNT },
            uRes: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) } 
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D uTex1;
            uniform sampler2D uTex2;
            uniform float uIncline;
            uniform float uCount; // Number of lenses
            varying vec2 vUv;

            void main() {
                // 1. Calculate the Sine Wave for the Lenses
                // We map UV.x to a repeating pattern. 
                // We add uIncline * PI to "shift" the phase of the wave based on tilt.
                float value = sin(vUv.x * uCount * 3.14159 + (uIncline * 4.0));

                // 2. Create the Mask
                // Remap sine (-1 to 1) to (0 to 1)
                float mask = value * 0.5 + 0.5;
                
                // Use smoothstep to sharpen the transition between images
                // This creates the "strip" effect rather than a ghost fade
                mask = smoothstep(0.4, 0.6, mask);

                // 3. Fetch Colors
                vec4 tex1 = texture2D(uTex1, vUv);
                vec4 tex2 = texture2D(uTex2, vUv);

                // 4. Mix Layers based on the lens mask
                vec4 color = mix(tex1, tex2, mask);

                // 5. ADD PLASTIC SPECULAR HIGHLIGHT (The "Ridge" look)
                // We calculate the edges of the sine wave to add a shine
                // abs(value) creates peaks at the transition points
                float shine = smoothstep(0.9, 1.0, abs(value)); 
                color.rgb += shine * 0.15; // Add 15% white shine to ridges

                gl_FragColor = color;
            }
        `
    });

    // Create a slightly larger plane to ensure coverage during tilt parallax
    const geometry = new THREE.PlaneGeometry(2, 2); 
    const plane = new THREE.Mesh(geometry, material);
    scene.add(plane);

    // 5. MOTION CONTROL LOGIC
    let targetIncline = 0.0;
    let currentIncline = 0.0;

    function handleOrientation(event) {
        // Gamma is left/right tilt (-90 to 90)
        let tilt = event.gamma || 0;
        
        // Limit tilt to a reasonable viewing angle (-30 to 30 degrees)
        // This ensures the user doesn't have to flip the phone upside down
        tilt = Math.max(-30, Math.min(30, tilt));

        // Normalize -30/30 to -1.0/1.0 range for the shader
        targetIncline = tilt / 30;
    }

    // 6. PERMISSIONS & INITIALIZATION
    const startBtn = document.getElementById('start-btn');
    const overlay = document.getElementById('overlay');

    const startExperience = () => {
        window.addEventListener('deviceorientation', handleOrientation);
        overlay.style.opacity = '0';
        setTimeout(() => overlay.style.display = 'none', 500);
    };

    startBtn.addEventListener('click', async () => {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const response = await DeviceOrientationEvent.requestPermission();
                if (response === 'granted') {
                    startExperience();
                } else {
                    alert('Permission denied. Please refresh and allow motion sensors.');
                }
            } catch (e) {
                console.error(e);
            }
        } else {
            startExperience();
        }
    });

    // 7. ANIMATION LOOP
    function animate() {
        requestAnimationFrame(animate);

        // HEAVIER LERP: 0.05 makes it feel like it has "mass" (smoother, less jittery)
        currentIncline += (targetIncline - currentIncline) * 0.05;
        
        // Update Shader
        material.uniforms.uIncline.value = currentIncline;
        
        // Subtle Parallax: Move the plane slightly opposite to the tilt
        // This makes the image feel like it's "inside" the screen
        plane.position.x = currentIncline * -0.1;
        plane.rotation.y = currentIncline * 0.1;

        renderer.render(scene, camera);
    }

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        material.uniforms.uRes.value.set(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
